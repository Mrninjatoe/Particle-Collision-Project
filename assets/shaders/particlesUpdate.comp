#version 460 core
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 0) buffer PositionBuffer {
		vec4 positions[];
};

layout (std430, binding = 1) buffer DirectionBuffer {
		vec4 directions[];
};

// alpha is radius
layout (std430, binding = 2) buffer ColorBuffer {
	vec4 colors[];
};

layout (std430, binding = 3) buffer VelocityBuffer{
	vec4 velocities[];
};

//bind depth and camera

layout(location = 5) uniform vec3 camPos;
layout(location = 6) uniform float delta;
layout(location = 7) uniform vec3 spawnPos;
layout(location = 8) uniform mat4 v;
layout(location = 9) uniform mat4 p;
layout(location = 10) uniform mat4 rv;

layout(location = 20) uniform sampler2D depth;
layout(location = 21) uniform sampler2D normals;
layout(location = 22) uniform sampler2D rDepth;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 viewSpacePoint(vec2 uv, bool r) {
	mat4 invProj = inverse(p);
	float z = 0;
	if(!r)
		z = texture(depth, uv).r;
	else
		z = texture(rDepth, uv).r;
	z = z * 2.0 - 1.0;
	vec4 clipSpacePos = vec4(uv * 2.0 - 1.0, z, 1.0);
	vec4 viewPos = invProj * clipSpacePos;
	viewPos = vec4(viewPos.xyz / viewPos.w, 1.0);

	return viewPos.xyz;
}

void main(){
	uint index = gl_GlobalInvocationID.x;
	vec4 pos = positions[index];
	vec4 dir = directions[index];
	vec4 color = colors[index];
	vec4 vel = velocities[index];

	vec2 candy = vec2(pos.a, vel.a); 
	
	if(candy.x < 0) {
		pos.xyz = spawnPos;
		vel.xyz = vec3(0);
		candy.x = candy.y;
	}

	vec4 viewPos = v * vec4(vec3(pos.xyz), 1);
	vec4 clipPos = p * viewPos;

	vec4 rViewPos = rv * vec4(vec3(pos.xyz), 1);
	vec4 rClipPos = p * rViewPos;

	vec2 proj0 = clipPos.xy / clipPos.w * 0.5 + 0.5;
	vec2 proj1 = rClipPos.xy / rClipPos.w * 0.5 + 0.5;

	vec3 bufferDepth = viewSpacePoint(proj0, false);
	vec3 rBufferDepth = viewSpacePoint(proj1, true);

	if(proj0.x > 0.0 && proj0.x < 1.0 && proj0.y > 0.0 && proj0.y < 1.0 && 
		bufferDepth.z < -1e-2 && bufferDepth.z > viewPos.z && bufferDepth.z < (viewPos.z + 0.1)) {

		vec3 n = texture(normals, proj0).xyz;
		vec3 r = reflect(normalize(vel.xyz), n);
	
		pos += vec4(n, 1) * 0.01;
		vel = vec4(r, 1) * 0.3 + cos(pos * 1e3) * 5e-4;
	}
	else if(proj1.x > 0.0 && proj1.x < 1.0 && proj1.y > 0.0 && proj1.y < 1.0 && 
		rBufferDepth.z < -1e-2 && rBufferDepth.z > rViewPos.z && rBufferDepth.z < (rViewPos.z + 0.1)) {

		vec3 n = texture(normals, proj1).xyz;
		vec3 r = reflect(normalize(vel.xyz), n);
		
		//pos += n * 1e-4;
		pos += vec4(n, 1) * 0.01;
		vel = vec4(r, 1) * 0.03 + cos(pos * 1e3) * 5e-4;
	
	}
	vel += vec4(0.0, -0.005 * 9.82, 0.0, 1);
	pos += vel * delta;


	color = colors[index];
	barrier();
	candy.x -= 1.0f * delta;
	pos.a = candy.x;
	vel.a = candy.y;

	

	positions[index] = pos;
	directions[index] = dir;
	colors[index] = color;
	velocities[index] = vel;
}






//// weird lösning below
	//vel = vel + 0.2f;// * delta; // 0.2 is accleration.
	//vec3 nextPos = (pos + (vel / 6 * dir * delta)).xyz;
	//
	//vec4 vpPos = p * v * vec4(nextPos, 1);
	//vec2 uv = vpPos.xy / vpPos.w * 0.5 + 0.5;
	//float bufferDepth = getDepth(uv);
	//float particleDepth = vpPos.z / vpPos.w;
	//
	//if(particleDepth > bufferDepth) {
	//	dir = vec4(0);
	//}
	//
	//pos = vec4(nextPos, 1);
	////pos = pos + (vel * dir * delta) + (0.5f * 0.2 * delta * delta);