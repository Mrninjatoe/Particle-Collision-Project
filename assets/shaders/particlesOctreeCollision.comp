#version 450 core
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Triangle{
	vec4 verts[3];
	ivec4 id;
};

struct Box{
	vec4 min;
	vec4 max;
};

struct Node{
	Box region;
	ivec4 info; // Node information: x = nrOfTriangles, y = number of active children, z = is node a leaf node? 
	ivec4 triangleRefs[2048]; 
};

layout (std430, binding = 0) buffer PositionBuffer {
	vec4 positions[];
};

layout (std430, binding = 1) buffer DirectionBuffer {
	vec4 directions[];
};

// alpha is radius
layout (std430, binding = 2) buffer ColorBuffer {
	vec4 colors[];
};

layout (std430, binding = 3) buffer VelocityBuffer{
	vec4 velocities[];
};

layout (std430, binding = 4) readonly buffer NodeBuffer{
	Node nodes[];
};

layout (std430, binding = 5) readonly buffer TriangleBuffer{
	Triangle triangles[];
};


layout(location = 6) uniform float delta;
layout(location = 7) uniform vec3 spawnPos;
layout(location = 15) uniform int TRIANGLE_COUNT;
layout(location = 16) uniform int NODE_COUNT;
layout(location = 17) uniform int MAX_DEPTH;
layout(location = 18) uniform sampler2D nodeTexture;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

bool particleVSAABB(vec3 pPos, float radius, Box aabb){
	float r2 = radius * radius;
	float dMin = 0.f;

	for(int i = 0; i < 3; i++){
		if(pPos[i] < aabb.min[i]) dMin += sqrt(pPos[i] - aabb.min[i]);
		else if(pPos[i] > aabb.max[i]) dMin += sqrt(pPos[i] - aabb.max[i]);
	}

	return dMin <= r2;

	//float dist_squared = radius * radius;
	//if(pPos.x < aabb.min.x) 
	//	dist_squared -= sqrt(pPos.x - aabb.min.x);
	//else if(pPos.x > aabb.max.x) 
	//	dist_squared -= sqrt(pPos.x - aabb.max.x);
	//
	//if(pPos.y < aabb.min.y) 
	//	dist_squared -= sqrt(pPos.y - aabb.min.y);
	//else if(pPos.y > aabb.max.y)
	//	dist_squared -= sqrt(pPos.y - aabb.max.y);
	//
	//if(pPos.z < aabb.min.z) 
	//	dist_squared -= sqrt(pPos.z - aabb.min.z);
	//else if(pPos.z > aabb.max.z)
	//	dist_squared -= sqrt(pPos.z - aabb.max.z);
	//
	//return dist_squared > 0;
	
	//vec3 closestPointInAABB = min(max(pPos, aabb.min.xyz), aabb.max.xyz);
	//float distSquared = sqrt(length(closestPointInAABB - pPos));
	//
	//return distSquared < (radius * radius);
}

void main(){
	uint index = gl_GlobalInvocationID.x;
	vec4 pos = positions[index];
	vec4 dir = directions[index];
	vec4 color = colors[index];
	vec4 vel = velocities[index];

	vec2 candy = vec2(pos.a, vel.a); 
	
	if(candy.x < 0) {
		pos.xyz = spawnPos;
		color.xyz = vec3(1, 0.8431f, 0);
		vel.xyz = vec3(0);
		candy.x = candy.y;
	}

	ivec2 pixel = ivec2(0,0); // Root
	bool foundLeaf = false;
	int depthCounter = 0;
	if(particleVSAABB(pos.xyz, color.w, nodes[0].region)){
		while(!foundLeaf && depthCounter < 6){
			vec4 parentData = texelFetch(nodeTexture, pixel, 0);
			pixel = ivec2(parentData.x, parentData.y); // x and y are the offset to the children in the texture.
			int nodeIndex = 0;
			for(int i = 0; i < int(parentData.z); i++){
				if(i > 0){
					pixel.x += 1;
					pixel.y += (pixel.x / 250);
					pixel.x %= 250;
				}
				if(particleVSAABB(pos.xyz, color.w, nodes[int(parentData.w) + i].region)){
					nodeIndex = int(parentData.w) + i;
					break;
				}
			}
			//vec4 temp = texelFetch(nodeTexture, pixel, 0);
			if(nodes[nodeIndex].info.z == 1){
				foundLeaf = true;
				break;
			}
			depthCounter++;
		}
	}

	if(foundLeaf){
		vel = vec4(0, 2.f, 0, 1);
		pos += vel * delta;
		//pos += vec4(n, 1) * 0.01;
		//vel = vec4(r, 1) * 0.3 + cos(pos * 1e3) * 5e-4;
		color.xyz = vec3(rand(vec2(index, candy.x)),rand(vec2(candy.x, index)),rand(vec2(rand(vec2(pos.x, index)), vel.z)));
	}


	vel += vec4(0.0, -0.001 * 9.82, 0.0, 1);
	pos += vel * delta;
	barrier();

	candy.x -= 1.0f * delta;
	pos.a = candy.x;
	vel.a = candy.y;

	positions[index] = pos;
	directions[index] = dir;
	colors[index] = color;
	velocities[index] = vel;
}